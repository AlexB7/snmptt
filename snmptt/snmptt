#!/usr/bin/perl
#
# SNMPTT v0.4
#
# Copyright 2002 Alex Burger
# alex_b@users.sourceforge.net
# 4/11/2002
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
##############################################################################
#
# http://www.sourceforge.net/projects/snmptt
#
# This script is a snmp trap handler for use with the NET-SNMP / UCD-SNMP 
# snmptrapd program.
#
# The script is called by defining a 'traphandle' in snmptrapd.conf.  
# For example:
#
# traphandle default /sbin/snmptt
# 
# SNMPTRAPD feeds details about the trap to the launched program's standard
# input in the following format (see snmptrapd.conf man page for a complete
# descriptipon)
#
# HOSTNAME: 	The name of the host in question  that  sent the  trap
# IPADDRESS: 	The IP address of the  host  that  sent  the trap
# VARBINDS: 	A  list  of  variable bindings that describe the trap and 
# 		the variables enclosed  in  it.  
#
# See the SNMPTT documentation (readme.html) for more information.
#
##############################################################################
#
sub showversion
{
	print "\nSNMPTT v0.4\n";
	print "(c) 2002 Alex Burger\n";
	print "http://snmptt.sourceforge.net\n\n";
}

##############################################################################
# Process command line arguments

use Getopt::Long;

$version = '';
$daemon = '';
$debug = '';
$debugfile = '';
$dump = '';
$help = '';
$time = '';
$ini = '';

GetOptions 	('version' => \$version, 
		'daemon' => \$daemon,
		'debug:i' => \$debug,
		'debugfile=s' => \$debugfile,
		'dump' => \$dump,
		'help' => \$help,
		'ini=s' => \$ini,
		'time' => \$time);  

if ($version == 1)
{
	&showversion;
	exit(0);
}

if ($help == 1)
{
$USAGE = qq/Usage:
    snmptt [<options>] 
Options:
    --daemon                             Run as a daemon
    --debug=n                            Set debug level (1 or 2)
    --debugfile=filename                 Set debug output file
    --dump                               Dump (display) defined traps
    --help                               Display this message
    --ini=filename                       Set configuration file to load
    --version                            Display author and version information
    --time                               Use to see how long it takes to load and 
                                         process trap file (eg: time snmptt --time)
/;
		
	&showversion;
	print $USAGE;

	exit(0);
}

if ($debug == 1)
{
	$DEBUGGING = 1;	
	$debugcmdline = 1;
}

if ($daemonmode == 1)
{
	$daemon = 1;	
	$daemoncmdline = 1;
}

if ($debug == 2)
{
	$DEBUGGING = 2;	
	$debugcmdline = 1;
}

if ($dump ==1)
{
	$DEBUGGING = 2;
	$debugcmdline = 1;
	&findsnmpttini;
	&loadsnmpttini;
	&loadsnmpttconf;		# Load SNMPTT.CONF file
	print ("\n\n");
	exit(0);
}

if ($time ==1)
{
	&findsnmpttini;
	&loadsnmpttini;
	&loadsnmpttconf;		# Load SNMPTT.CONF file
	exit(0);
}

if ($debugfile ne '') 
{
	$DEBUGGING_FILE = $debugfile;	# commandline overpowers snmptt script
	$debugfilecmdline = 1;
}

##############################################################################
#
# Load config file 
#

&findsnmpttini;
&loadsnmpttini;
		
##############################################################################

use Text::ParseWords;
use POSIX qw(strftime);

if ($syslog_enable == 1)
{
	require Sys::Syslog;
}

if ($mysql_dbi_enable == 1)
{
	require DBI;
	$dbhmysql = DBI->connect("DBI:mysql:$mysql_dbi_database",$mysql_dbi_username,$mysql_dbi_password);
	warn "Unable to connect: $DBI::errstr\n" unless (defined $dbhmysql);

}

if ($sql_win32_odbc_enable == 1)
{
	require Win32::ODBC;
	$dbhodbc = new Win32::ODBC("DSN=$sql_win32_odbc_dsn","UID=$sql_win32_odbc_username","PWD=$sql_win32_odbc_password");
	warn "Unable to connect to DSN $sql_win32_odbc_dsn:" . Win32::ODBC::Error() . "\n" unless (defined $dbhodbc);

}

if ($DEBUGGING >= 1)
{
	if ($DEBUGGING_FILE ne '') 
	{
	  	open DEBUGFILE, ">>$DEBUGGING_FILE"
			or warn "Could not open debug output file ($!)";
	
		select DEBUGFILE;	# Change default output to debug file
	}
	
	# Print out time
	print "SNMPTT started: ",scalar(localtime),"\n\n"
}		

##############################################################################
####  MAIN SECTION START

# Pull in passed SNMP info from snmptrapd via STDIN and place in the array @tempvar

if ($daemon == 1)
{
	$SIG{HUP} = \&signal_handler_reload;

	$SIG{TERM} = \&signal_handler_die;
	
	$timetoreload = 0;
	$timetodie = 0;

	&loadsnmpttconf;	# Load SNMPTT.CONF file

	# Only fork to the background if not Win32
	if (($^O ne "MSWin32") && ($daemon_fork==1))
	{
		use POSIX qw(setsid);
	
		chdir '/'
		   or die "Can't chdir to /: $!";
		open STDIN, '/dev/null'
		   or die "Can't read /dev/null: $!";
		open STDOUT, '>>/dev/null'
		   or die "Can't write to /dev/null: $!";
		open STDERR, '>>/dev/null'
		   or die "Can't write to /dev/null: $!";
		defined(my $pid = fork)
		   or die "Can't fork: $!";
		exit if $pid;
		POSIX:setsid
		   or die "Can't start a new session: $!";
		umask 0;
	}
	
	while (!$timetodie)
	{
	
		
		if (! (chdir($spool_directory)))
		{
			if ($DEBUGGING >= 1)
			{
				print "Unable to enter dir $spool_directory:$!\n";
			}
			warn "Unable to enter dir $spool_directory:$!\n";
		}
		elsif (! (opendir(DIR, ".")))
		{
			if ($DEBUGGING >= 1)
			{
				print "Unable to open $spool_directory:$!\n";
			}
			warn "Unable to open $spool_directory:$!\n";
		}
		elsif (! (@filenames = readdir(DIR)))
		{
		
			if ($DEBUGGING >= 1)
			{
				print "Unable to read $spool_directory:$!\n";
			}
			warn "Unable to read $spool_directory:$!\n";
		}
		else
		{
			closedir(DIR);
			
			foreach my $file (@filenames)
			{
				next if ($file eq ".");
				next if ($file eq "..");
			
				if ($DEBUGGING >= 1)
				{
					print "Processing file: $file\n";
				}
			
				$filesuccess = 1;
				unless (open FILE, $spool_directory.$file)
				{
					if ($DEBUGGING >= 1)
					{
						print "Could not open trap file $spool_directory$file: ($!)\n";
					}
					warn "Could not open trap file $spool_directory$file: ($!)\n";
					$filesuccess = 0;
				}
						
				$input = 'FILE';
		
				&readtrap;		# Read trap from STDIN or file
		
				&searchfortrap;		# Search for trap snmptt.conf (array)
	
				close FILE;
	
				if ($filesuccess == 1)
				{
					unless (unlink($file))
					{
						if ($DEBUGGING >= 1)
						{
							print "Unable to delete $file:$!\n";
						}
						warn "Unable to delete $file:$!\n";
					}
				}
			}
		}
		if ($DEBUGGING >= 1)
		{
			print "Sleeping for $sleep seconds\n\n";
		}
		sleep $sleep;

		if ($timetoreload == 1)
		{
			if ($DEBUGGING >= 1)
			{
				print "Reloading configuration file\n\n";
			}
			&loadsnmpttini;		# Load ini file
			&loadsnmpttconf;	# Load SNMPTT.CONF file
			$timetoreload = 0;
		}
	}
}
else
{
	$input = 'STDIN';
	
	&readtrap;		# Read trap from STDIN or file

	&loadsnmpttconf;	# Load SNMPTT.CONF file

	&searchfortrap;		# Search for trap snmptt.conf (array)
}

if (defined $dbimysql)
{
	$dbhmysql->disconnect;
}
if (defined $dbiodbc)
{
	$dbhodbc->close();
}

exit();

####  MAIN SECTION END

sub processtrap
{
	# Variables of trap received by SNMPTRAPD:
	# 
	# @var[0]		hostname
	# @var[1] 		ip address
	# @var[2] 		uptime
	# @var[3] 		trapname / OID
	# @var[4] 		ip address from trap agent
	# @var[5] 		trap community string
	# @var[6] 		enterprise
	#
	# @entvar[0]		passed variable 1
	# @entvar[0]		passed variable 2
	# .
	# .
	# etc..
	# 
	# $event hash for each trapped defined in snmptt.conf with following values:
	# 
	# 0: name of trap
	# 1: category
	# 2: severity
	# 3: FORMAT string
	# 4: EXEC string
	# 5: NODES string
	#
	# Example: 	To access FORMAT string for received trap:
	# 		$event{"@var[3]"}[3]
	#
	#		or
	# 		
	# 		$event{"$receivedtrap"}[3]	
	###############################################################################
	# if no nodes list, then $hostmatch = 1 so trap is logged etc, otherwise it is not

	$l = 1;	# Start with first event entry

	$multiple_event_passes = 0;	# Below, if =1, then abort because we already found a match for
					# this trap.  This would only happen if you have a trap
					# defined multiple times in the config file to allow 
					# different machines to have different actions based on 
					# the node name.
	
	while (defined($event{$receivedtrap}[$l+1]))
	{
		if ($DEBUGGING >= 1)
		{
			print  "Working with event entry: $receivedtrap => $event{$receivedtrap}[0+$l],$event{$receivedtrap}[1+$l],$event{$receivedtrap}[2+$l],$event{$receivedtrap}[5+$l]\n";
		}
		
		$hostmatch = 0;
	
		# $event is the hash of events defined in the config file
		# $event2 is a copy of the matching event
	
		# Flush out @event2
		@event2 = ();
	
		#	$event2[0]=$event{"$receivedtrap"}[0];	# 0: name of trap	
		#	$event2[1]=$event{"$receivedtrap"}[1];	# 1: category
		#	$event2[2]=$event{"$receivedtrap"}[2];	# 2: severity
		#	$event2[3]=$event{"$receivedtrap"}[3];	# 3: FORMAT string
		#	$event2[4]=$event{"$receivedtrap"}[4];	# 4: EXEC string
		#	$event2[5]=$event{"$receivedtrap"}[5];	# 5: NODES string
		
		$event2[0]=$event{"$receivedtrap"}[0+$l];	# 0: name of trap	
		$event2[1]=$event{"$receivedtrap"}[1+$l];	# 1: category
		$event2[2]=$event{"$receivedtrap"}[2+$l];	# 2: severity
		$event2[3]=$event{"$receivedtrap"}[3+$l];	# 3: FORMAT string
		$event2[4]=$event{"$receivedtrap"}[4+$l];	# 4: EXEC string
		$event2[5]=$event{"$receivedtrap"}[5+$l];	# 5: NODES string
	
		$l+=7;
			
		if ($event2[5] eq '')
		{
			$hostmatch = 1;		# No nodes defined, so default to all nodes
			$multiple_event_passes++;
			$processed = 1;
			if ($DEBUGGING >= 1)
			{
			  print "  No nodes defined for this entry so all nodes will match\n";
			}
		}
		else
		{
			if ($DEBUGGING >= 1)
			{
			  print "  Nodes defined for this entry...\n";
			}	
			
			if ($event2[5] =~ /\\|\// )	# Contain a \ or /?  Must be a filename
			{
				if (open NODESFILE, $event2[5])
				{
					while (defined($line = <NODESFILE>))
					{
						chomp($line);
						$line = $line;
						
						# Allow comment lines starting with a #
						if (!($temp =~ /((^#)|(\s+#)).*/))
						{
							push (@nodes, $line);
						}
					}
					close LOGFILE;
				}
				else
				{
					warn "Cannot open NODES file: $event2[5] $!";
				}
				
				#load file
				#
				#
			}
			else 	# Must be a list of nodes
			{
				@nodes = split /\s/, $event2[5];
			}
	
			foreach $a (@nodes)
			{	
				if ($a =~ /(\d+\.\d+\.\d+\.\d+)/) # NODES entry is an IP address
				{
					if ( $a eq @var[1])     # compare against ip
					{
						$hostmatch = 1;
						$processed = 1;
					}
				}
	                        elsif (lc $a eq lc @var[0])	# NODES entry is a host name.  Do lowercase compare	
				{
					$hostmatch = 1;
					$processed = 1;
				}
			}
			if ($hostmatch == 1)
			{
			  $multiple_event_passes++;
			  
			  if ($DEBUGGING >= 1)
 			  {
			  	print "  Node found in list\n";
			  }
			}
		}
	
		if ($hostmatch == 1 && $event2[1] ne "IGNORE")
		{
			#print "multiple_event_passes is $multiple_event_passes\n";
			#print "multiple_event is $multiple_event\n";
			if (($multiple_event == 0) && ($multiple_event_passes > 1))
			{
				if ($DEBUGGING >= 1)
 				{
			  		print "  multiple_event = $multiple_event, multiple_event_passes = " .
					"$multiple_event_passes so don't process any more entries\n";
				}
				last;	# Don't look any further - stop

			}

			print "  multiple_event = $multiple_event, multiple_event_passes = " . "$multiple_event_passes\n";			
			# Trap received exists in our list of trap definitions
			if ($DEBUGGING >= 1)
			{
				print "\nTrap defined, processing...\n\n";
			}
			# Variable substitution for FORMAT string
			
			$_ = $event2[3];	# FORMAT string
		
			&substitute;
		
			$message = "$receivedtrap $event2[2] \"$event2[1]\" @var[0] - $_\n";
		
			if ($stdout_enable == 1 || $DEBUGGING >= 1)
			{
				print "$message";
			}
		
			if ($log_enable == 1)
			{
				if (open LOGFILE, ">>$log_file")
				{
					print LOGFILE scalar(localtime)." $message";
					close LOGFILE;
				}
				else
				{
					warn "Cannot open log_file: $!";
				}
			}
	
			if ($syslog_enable == 1)
			{
				if (Sys::Syslog::openlog('TRAPD', '',$syslog_facility) )
				{
					Sys::Syslog::syslog ($syslog_level, $message,1);
					Sys::Syslog::closelog();
				}
				else
				{
					warn "Cannot open log_file: $!";
				}
			}
			
			if ($mysql_dbi_enable == 1)
			{
				$message = $_;
				
				$sth = $dbhmysql->prepare(
					"INSERT $mysql_dbi_table (eventname, eventid, enterprise, community, 
					hostname, agentip, category, severity, uptime, traptime, formatline) VALUES 
					(?,?,?,?,?,?,?,?,?,?,?)") or
				 warn "Unable to prepare our query: ".$dbh->errstr."\n";

				 if (defined $sth) {
					 $sth->execute($event2[0],$receivedtrap,@var[6],@var[5],@var[0],@var[4],$event2[1],
					 $event2[2],@var[2],scalar(localtime),$message)
					 or warn "Unable to execute our query: ".$dbhmysql->errstr."\n";

				 	$sth->finish;
				 }
			}				 
			
			if ($sql_win32_odbc_enable == 1)
			{
				$message = $_;
				
				if (defined $dbhodbc->Sql
				        ("INSERT INTO $sql_win32_odbc_table (eventname, eventid, enterprise, community, 
					hostname, agentip, category, severity, uptime, traptime, formatline) VALUES (
					\'$event2[0]\',\'$receivedtrap'\,\'@var[6]\',\'@var[5]\',\'@var[0]\',\'@var[4]\',
					\'$event2[1]\',\'$event2[2]\',\'@var[2]\',\'".scalar(localtime)."\',
					\'$message\')" ) )
				{					
					warn "Unable to perform INSERT INTO: ".Win32::ODBC::Error()."\n";
		 	 	}
			}				 

			
			#
			# Variable substitution for EXEC string
			#
		
			if ($event2[4] ne '' && $event2[1] ne "LOGONLY")
			{
				
				$_ = $event2[4];	# EXEC string
			
				&substitute;
		
				$page = $_;
			
				if ($exec_enable == 1)
				{
					if ($DEBUGGING >= 1)
					{	
						print "EXEC command:$page\n";
					}
					# Send page
					system $page;
				}
			}
			elsif ($DEBUGGING >= 1)
			{
				if ($event2[1] eq "LOGONLY")
				{
					print "\n\nTrap set to LOGONLY...\n\n";
				}
			}
		}
		else
		{
			if ($DEBUGGING >= 1)
			{
				if ($event2[1] eq "IGNORE")
				{
					print "\n\nTrap set to IGNORE...\n\n";
				}
				else
				{
					print "\n\nTrap defined, but host @var[0] does not match...\n\n";
				}
			}
		}
	
	} #while defined..
}

sub substitute
{
	# Perform substitution on $_ variable

	# $n - Variable-bindings
	for($i=0;$i <= $#entvar+1; $i++)
	{
		s(\$$i)($entvar[$i-1])g;
	}

	# $c - Category
	s(\$c)($event2[1])g;
	
	# $C - Trap community string
	s(\$C)(@var[5])g;
	
	# $E, $e - Enterprise trap as Object ID string of numbers
	s(\$E)(@var[6])g;
	s(\$e)(@var[6])g;
	
	# $N - Event name
	s(\$N)($event2[0])g;
	
	# $# - Number of variable-bindings in the trap
	s(\$#)($#entvar)g;

	# $$ - Print a $
	s(\$\$)(\$)g;

	# $O, $o - Received trap
	s(\$O)($receivedtrap)g;
	s(\$o)($receivedtrap)g;	
	
	# $s - Severity
	s(\$s)($event2[2])g;
	
	# $AR, $ar - Hostname
	s(\$aR)(@var[1])g;
	s(\$ar)(@var[1])g;

	# $R, $r - IP address
	s(\$R)(@var[0])g;
	s(\$r)(@var[0])g;
	
	# $A, $a - Trap agent IP address
	s(\$aA)(@var[4])g;
	s(\$A)(@var[4])g;
	
	# $T - Uptime
	s(\$T)(@var[2])g;
	
	# $x - Current date
	$mydate = strftime "%a %b %e %Y", localtime;
	s(\$x)($mydate)g;	

	# $x - Current time
	$mytime = strftime "%H:%M:%S", localtime;
	s(\$X)($mytime)g;	

	# $@ - Current time since epoch (Jan 1, 1904 for Mac, Jan 1, 1900 for most others)
	$mytime = time();
	s(\$@)($mytime)g;
	
	if ($receivedtrap =~ /^.1.3.6.1.6.3.1.1.5/)
        {
		# It's a generic trap

		# $S - Specific trap number - 0
		s(\$S)(0)g;

		# $G - Generic trap number - last #
		my $temp = $_; 		# Save old $_
		$_ = $receivedtrap;
		/(\d+)$/;
		my $temp2 = $1;
		$_ = $temp;		# Restore old $_
		s(\$G)($temp2)g;
	}
	else
	{
		# It's an enterprise trap

		# $S - Specific trap number - last #
		my $temp = $_; 		# Save old $_
		$_ = $receivedtrap;
		/(\d+)$/;
		my $temp2 = $1;
		$_ = $temp;		# Restore old $_
		s(\$S)($temp2)g;

		# $G - Generic trap number - 0
		s(\$G)(0)g;	  
	}	

	# $* - Expand all variable-bindings
	s(\$\*)(@entvar)g;
}

sub loadsnmpttconf
{
	#
	# snmptt.conf loader.
	# This section loads the snmptt.conf which defines the traps and text strings
	# that will be used for variable substitution

	# Flush variables in case this is a re-load during run
	@snmpttconf = ();
	# @snmptt_conf_files = ();
	undef %event;
	
	foreach $snmpttconffile (@snmptt_conf_files)
	{
		open SNMPTTCONF, $snmpttconffile
			or die "Could not open snmptt.conf file: $snmpttconffile ($!)";
			if ($DEBUGGING >= 1)
		{
			print "\n\tLoading $snmpttconffile\n";
		}
		
		$tempcount = 0;
		while (<SNMPTTCONF>)
		{
			chomp;				#remove <cr> at end of line	
			push(@snmpttconf, $_);		#add to each line to @trapconf array
			$tempcount++;
		}
	
		if ($DEBUGGING >= 1)
		{
			print "\tFinished loading $tempcount lines from $snmpttconffile\n";
		}
	}
		if ($DEBUGGING >= 1)
	{
		print "\nFinished loading list of files to load from $snmpttconffile\n";
	}
	
	# Process each line of snmptt.conf loaded into @snmpttconf array.
	# Add each EVENT to %event hash
	
	if ($DEBUGGING >= 1)
	{
		print "\nProcessing memory copy of $snmpttconffile\n";
	}
	
	$currentline=0;
	$tempcount=0;
	$tempcount2=0;
	
	while ($currentline <= $#snmpttconf)
	{
		$line = @snmpttconf[$currentline];
	
		if ($line =~ /^EVENT/)
		{
			#EVENT name .x.x.x.x "category" severity  (note: .x.x. is FULL OID!)
			#0      1       2        3         4
			
			# use shellwords to divide the two space separated values
			# without messing up quoted text and re-join using :: as the
			# delimiter
			#
			# hash elements:
			# 0: name of trap
			# 1: category
			# 2: severity
			# 3: FORMAT string
			# 4: EXEC string
			# 5: NODES string
			
			$tempcount++;		# Temporary counter of the number of EVENTS found
			
			# Divide up line taking into consideration strings in quotes
			$temp = join "::", shellwords($line);                
	
			#print "line is: $temp\n";
	
			# Split line up into multiple elements of an array using the new delimiter
			@temp = split ("::",$temp);
					
			# Clear out the FORMAT, EXEC and NODES lines in case they are not found.  Don't want old
			# data in them..
			$lineformat = '';
			$lineexec = '';
			$linenodes = '';
	
			$currentline++; # Increment to the next line which should be a FORMAT, EXEC or NODES
			$line2 = @snmpttconf[$currentline];
			
			while ( ($currentline <= $#snmpttconf) && !($line2 =~ /^EVENT/) )
			{
				# Keep going through the file until the next EVENT or the end of snmptt.conf
				# is reached
			
				# Check to see if next line is a FORMAT line (it should be!)
				if ($line2 =~ /^FORMAT/)
				{
					# It's a FORMAT line
					
					$lineformat = substr($line2,7);
				}
				elsif ($line2 =~ /^EXEC/)
				{
					# It's an EXEC line
					
					$lineexec = substr($line2,5);
				}
				elsif ($line2 =~ /^NODES/)
				{
					# It's a NODES line
					
					$linenodes = substr($line2,6);
				}
				$currentline++; # Increment to the next line
				$line2 = @snmpttconf[$currentline]; # Get next line
			}
			if ($lineformat ne '')
			{			
				# At least the mandatory FORMAT line was defined, so we'll keep it
				# Stuff all elements into a one hash
				# $event{@temp[2]} = [@temp[1],@temp[3],@temp[4],$lineformat,$lineexec,$linenodes];

				if (!defined(@{ $event{@temp[2]} }[0])) 
				{  
					@{ $event{@temp[2]} }[0] = 0;
				}

				$countx = @{ $event{@temp[2]} }[0];
				#print "countx $countx\n";
				@{ $event{@temp[2]} }[1+$countx]= @temp[1];
				@{ $event{@temp[2]} }[2+$countx]= @temp[3];
				@{ $event{@temp[2]} }[3+$countx]= @temp[4];
				@{ $event{@temp[2]} }[4+$countx]= $lineformat;
				@{ $event{@temp[2]} }[5+$countx]= $lineexec;
				@{ $event{@temp[2]} }[6+$countx]= $linenodes;
				@{ $event{@temp[2]} }[0]= 7+ @{ $event{@temp[2]} }[0];
				
				$tempcount2++;		# Temporary counter of the number of EVENTS found with at
							# least a FORMAT line specified
			}
	
			# Change currentline back so the next increment will re-evalutate the last line which
			# would have been an EVENT (to get out of the WHILE loop above), or the end of the file
			$currentline--;
		}
		$currentline++;		# Increment current line for next loop through snmpttconf array	
	}
	if ($DEBUGGING >= 1)
	{
		print "$tempcount EVENTs found\n";
		print "$tempcount2 EVENTs found that contain at least the mandatory FORMAT line\n";
		if($tempcount2<$tempcount)
		{
			print "  Warning:  EVENT entries were found that did not contain the mandatory FORMAT line!\n";
			print "  These EVENTS will be ignored!\n";
		}
		print "Finished processing memory copy of $snmpttconffile\n\n";
	}
	
	if ($DEBUGGING >= 2)
	{
		print "Printing out all the events in hash table:\n\n";
		foreach $key (sort keys %event)
		{		
			$l=0;
			while (defined($event{$key}[$l+1]))
			{	
				print  "hash: $key => $event{$key}[1+$l],$event{$key}[2+$l],$event{$key}[3+$l],$event{$key}[4+$l]\n";
			$l+=7;
			}

		}
		print "Finished printing out all events in hash table\n";
	}

	close SNMPTTCONF;
}

sub readtrap
{
	# Flush out @tempvar, @var and @entvar
	@tempvar = ();
	@var = ();
	@entvar = ();

	chomp($tempvar[0]=<$input>);	#hostname
	chomp($tempvar[1]=<$input>);	#ip address
	
	# Some systems pass the IP address as udp:ipaddress:portnumber.  This will pull
	# out just the IP address
	@tempvar[1] =~ /(\d+\.\d+\.\d+\.\d+)/;
	@tempvar[1] = $1;
	
	#Process varbinds
	#Separate everything out, keeping both the variable name and the value
	while (defined($line = <$input>))
	{
		# use shellwords to divide the two space separated values
		# without messing up quoted text and re-join using :: as the
		# delimiter (Add a space to the end otherwise we loose lines 
		# that contain just a 0)
	
		$temp = join "::", shellwords($line)," ";                
	
		# Chop off last two
		chop ($temp);
		chop ($temp);
		chop ($temp); # Cut off that extra space from above
	
		# Split using the new delimiter
		@temp = split ("::",$temp);
	
		# Normally it is expected that a line contains a variable name
		# followed by a space followed by the value (except for the 
		# first line which is the hostname and the second which is the
		# IP address).  If there is no variable name on the line (only
		# one string), then add a variable string called 'variable' so 
		# it is handled correctly in the next section.
		# This happens with ucd-snmp v4.2.3 but not v4.2.1 or v4.2.5.
		# This appears to be a bug in ucd-snmp v4.2.3.  This works around
		# the problem although v4.2.3 should NOT be used with SNMPTT as 
		# it prevents SNMP V2 traps from being handled correctly.
	        if (@temp[1] eq "")
	        {
	                print "Data passed from snmptrapd is incorrect.  UCD-SNMP 
				v4.2.3 is known to cause this\n";
	                @temp[1] = @temp[0];
	                @temp[0] = "variable";
	        }
	
		# Add two strings to @tempvar
		push(@tempvar, @temp);
	}
	
	if ($DEBUGGING >= 2)
	{
		# Print out all items passed from snmptrapd
		print "Items passed from snmptrapd:\n";
		for ($i=0;$i <= $#tempvar;$i++)
		{
			print "value $i: @tempvar[$i]\n\n";
		}
	}
	
	# Copy what I need to new variables to make it easier to manipulate later
	
	# Standard variables
	@var[0] = @tempvar[0];		# hostname
	@var[1] = @tempvar[1];		# ip address
	@var[2] = @tempvar[3];		# uptime
	@var[3] = @tempvar[5];		# trapname / OID - assume first value after uptime is
					# the trap OID (value for .1.3.6.1.6.3.1.1.4.1.0)
	
	@var[4] = "";	# Clear ip address from trap agent
	@var[5] = "";	# Clear trap community string
	@var[6] = "";	# Clear enterprise
	
	# Cycle through remaining variables searching for for agent IP (.1.3.6.1.6.3.18.1.3.0),
	# community name (.1.3.6.1.6.3.18.1.4.0) and enterpise (.1.3.6.1.6.3.1.1.4.3.0)
	# All others found are regular passed variables
	$j=0;
	for ($i=6;$i <= $#tempvar; $i+=2)
	{
		if (@tempvar[$i] =~ /^.1.3.6.1.6.3.18.1.3.0$/)		# ip address from trap agent
		{
			@var[4] = @tempvar[$i+1];
		}
		elsif (@tempvar[$i] =~ /^.1.3.6.1.6.3.18.1.4.0$/)	# trap community string
		{
			@var[5] = @tempvar[$i+1];
		}
		elsif (@tempvar[$i] =~ /^.1.3.6.1.6.3.1.1.4.3.0$/)	# enterprise
		{
			@var[6] = @tempvar[$i+1];
		}
		else	# application specific variables
		{
			@entvar[$j] = @tempvar[$i+1];
			$j++;
		}
		
	}
	
	if ($DEBUGGING >= 1)
	{
		print "Trap received from @tempvar[0]: @tempvar[5]\n";
	}
	
	if ($DEBUGGING >= 2)
	{
		print "0:		hostname\n";
		print "1:		ip address\n";
		print "2:		uptime\n";
	 	print "3:		trapname / OID\n";
		print "4:		ip address from trap agent\n";
		print "5:		trap community string\n";
		print "6:		enterprise\n";
		print "0+:		passed variables\n\n";	
		
		#print out all standard variables
		for ($i=0;$i <= $#var;$i++)
		{
			print "Value $i: @var[$i]\n\n";
		}
		#print out all enterprise specific variables
		for ($i=0;$i <= $#entvar;$i++)
		{
			print "Value $i: @entvar[$i]\n\n";
		}
	}
		
	# Variables of trap received by SNMPTRAPD:
	# 
	# @var[0]		hostname
	# @var[1] 		ip address
	# @var[2] 		uptime
	# @var[3] 		trapname / OID
	# @var[4] 		ip address from trap agent
	# @var[5] 		trap community string
	# @var[6] 		enterprise
	#
	# @entvar[0]		passed variable 1
	# @entvar[0]		passed variable 2
	# .
	# .
	# etc..
	#
	##############################################################################
	
}
	
sub searchfortrap
{
		
	# Variables of trap received by SNMPTRAPD:
	# 
	# @var[0]		hostname
	# @var[1] 		ip address
	# @var[2] 		uptime
	# @var[3] 		trapname / OID
	# @var[4] 		ip address from trap agent
	# @var[5] 		trap community string
	# @var[6] 		enterprise
	#
	# @entvar[0]		passed variable 1
	# @entvar[0]		passed variable 2
	# .
	# .
	# etc..
	# 
	# $event hash for each trapped defined in snmptt.conf with following values:
	# 
	# 0: name of trap
	# 1: category
	# 2: severity
	# 3: FORMAT string
	# 4: EXEC string
	# 5: NODES string
	#
	# Example: 	To access FORMAT string for received trap:
	# 		$event{"@var[3]"}[3]
	#
	#		or
	# 		
	# 		$event{"$receivedtrap"}[3]	
	###############################################################################
	# Check to see if received trap is defined in the snmptt.conf, and perform variable
	# substitution, logging etc if found
	
	# Look for matching OID
	
	$processed = 0;
	$receivedtrap = @var[3];
	
	# Check for exact match
	if (exists $event{"$receivedtrap"})
	{
		if ($DEBUGGING >= 1)
		{
			print "Exact match of trap found in EVENT hash table\n\n";
		}
		
		&processtrap;
		#$processed = 1;
	}
	else
	{
		if ($DEBUGGING >= 1)
		{
			print "Exact match of trap NOT found in EVENT hash table\n\n";
		}
	}
	
	# Check for wildcard match in hash table if not already processed
	if ($processed == 0)
	{
		$receivedtraptemp = $receivedtrap;
		
		$counter = 0;	# Drill down only 40 times.  Should never need this, but
				# it's here to prevent an infinite loop in this while statement
				# just in case
		while ($counter <= 40 && $receivedtraptemp ne '')
		{
			# Remove last digit of recevied trap, add a * and look for match
			$receivedtraptemp =~ s/(.*)\.\d+$/\1/;
	
			if ($DEBUGGING >= 2)
			{
				print "Drilling down looking for wildcards in the EVENT hash table\n";
				print $receivedtraptemp.".\*\n\n";
			}
			
			if (exists $event{$receivedtraptemp.'.*'})
			{
				$receivedtrap = $receivedtraptemp.'.*';	# Set $receivedtrap to matching trap with wildcard
				&processtrap;
				#$processed = 1;
				last;	# found, so stop this while loop
			}
			$counter++;
		}
	}
	
	# Log to unknowntraplog etc if no match was found
	if ($processed == 0)
	{
		if ($DEBUGGING >= 1)
		{
			print "\n\nTrap not defined.  Nothing to do...\n\n";
		}
		
		if ($unknown_trap_log_enable == 1)
		{
			if (open LOGFILE, ">>$unknown_trap_log_file")
			{	
				print LOGFILE scalar(localtime),": Unknown trap (@var[3]) received from @var[0] at: \n";
				#print out all standard variables
				for ($i=0;$i <= $#var;$i++)
				{
					print 	LOGFILE "Value $i: @var[$i]\n";
				}
				#print out all enterprise specific variables
				for ($i=0;$i <= $#entvar;$i++)
				{
					print LOGFILE "Value $i: @entvar[$i]\n";
				}
				print LOGFILE "\n\n";
				close LOGFILE;
			}
			else
			{
				warn "Cannot open log_file: $!";
			}
		}
	}
}

sub findsnmpttini
{
	##############################################################################
	# Load config file start
	# 
	# For Linux / Unix, try /etc/snmp/snmptt.ini first, /etc/snmptt.ini second.
	#
	# For Windows, try %SystemRoot%\snmptt.ini only.
	# 
	if ($ini ne '')
	{
	  $configfile = $ini;
	}
	else
	{	
	 	if ($^O ne "MSWin32")
		{
		  $configfile = '/etc/snmp/snmptt.ini';
		  if( open( CONFIG, '/etc/snmp/snmptt.ini' ) )
		  {
		    $configfile = '/etc/snmp/snmptt.ini';
		    close CONFIG;
		  }
		  elsif ( open( CONFIG, '/etc/snmptt.ini' ) )
		  {
		    $configfile = '/etc/snmptt.ini';
		    close CONFIG;
		  }
		}
		else {
		  $configfile = $ENV{'SystemRoot'}."\\snmptt.ini";
		}
	}
	##############################################################################
}
      
sub loadsnmpttini {

	##############################################################################
	# 
	# Load config file start
	# 
	use Config::IniFiles;
	my $cfg;

	#
	##############################################################################

	if( open( CONFIG, $configfile ) ) {
	  close CONFIG;
	  $cfg = new Config::IniFiles( -file => $configfile);
	}
	else
	{
	  if ($DEBUGGING >= 1) {
	  	print "Config file could not be loaded\n";
	  }
	  exit(1);
	}
	
	if (! $cfg)
	{
	  if ($DEBUGGING >= 1) {
		  print "Error in config file - please check the syntax in the config file\n";
	  }
	  exit(1);
	}
	
	# 
	# Defaults Start
	# 
        $daemonmode = 0;
	$multiple_event = 0;
	$daemon_fork = 1;
	$spool_directory = '';
	$sleep = 5;
	$stdout_enable = 0;
	$log_enable = 1;
	$log_file = '';
	$unknown_trap_log_enable = 0;
	$unknown_trap_log_file = '';
	$syslog_enable = 0;
	$syslog_facility = 'local0';
	$syslog_level = 'warning';
	$exec_enable = 1;
	$mysql_dbi_enable = 0;
	$mysql_dbi_database = '';
	$mysql_dbi_table = '';
	$mysql_dbi_username = '';
	$mysql_dbi_password = '';
	$sql_win32_odbc_enable = 0;
	$sql_win32_odbc_dsn = '';
	$sql_win32_odbc_table = '';
	$sql_win32_odbc_username = '';
	$sql_win32_odbc_password = '';
	if ($debugcmdline == 0) {
	  $DEBUGGING = 0
	}
	if ($debugfilecmdline == 0) {
	  $DEBUGGING_FILE = ''
	}
	@snmptt_conf_files = '';
	#
	# Defaults End
	# 
	
	# General
	if ($cfg->val('General', 'mode') eq "standalone") {
	  $daemonmode = 0;
	}
	else {
	  $daemonmode = 1;
	}
	$multiple_event = $cfg->val('General', 'multiple_event');
	
	# DaemonMode
	if ($daemoncmdline == 0) {
	  $daemon_fork = $cfg->val('DaemonMode', 'daemon_fork');
	}
	$spool_directory = $cfg->val('DaemonMode', 'spool_directory');
	$sleep = $cfg->val('DaemonMode', 'sleep');
	
	# Logging
	$stdout_enable = $cfg->val('Logging', 'stdout_enable');
	$log_enable = $cfg->val('Logging', 'log_enable');
	$log_file = $cfg->val('Logging', 'log_file');
	$unknown_trap_log_enable = $cfg->val('Logging', 'unknown_trap_log_enable');
	$unknown_trap_log_file = $cfg->val('Logging', 'unknown_trap_log_file');
	$syslog_enable = $cfg->val('Logging', 'syslog_enable');
	$syslog_facility = $cfg->val('Logging', 'syslog_facility');
	$syslog_level = $cfg->val('Logging', 'syslog_level');
	
	# Exec
	$exec_enable = $cfg->val('Exec', 'exec_enable');
	
	# SQL
	$mysql_dbi_enable = $cfg->val('SQL', 'mysql_dbi_enable');
	$mysql_dbi_database = $cfg->val('SQL', 'mysql_dbi_database');
	$mysql_dbi_table = $cfg->val('SQL', 'mysql_dbi_table');
	$mysql_dbi_username = $cfg->val('SQL', 'mysql_dbi_username');
	$mysql_dbi_password = $cfg->val('SQL', 'mysql_dbi_password');
	
	$sql_win32_odbc_enable = $cfg->val('SQL', 'sql_win32_odbc_enable');
	$sql_win32_odbc_dsn = $cfg->val('SQL', 'sql_win32_odbc_dsn');
	$sql_win32_odbc_table = $cfg->val('SQL', 'sql_win32_odbc_table');
	$sql_win32_odbc_username = $cfg->val('SQL', 'sql_win32_odbc_username');
	$sql_win32_odbc_password = $cfg->val('SQL', 'sql_win32_odbc_password');
	
	# Debugging
	if ($debugcmdline == 0) {
	  $DEBUGGING = $cfg->val('Debugging', 'DEBUGGING');
	}
	if ($debugfilecmdline == 0) {
	  $DEBUGGING_FILE = $cfg->val('Debugging', 'DEBUGGING_FILE');
	}
	
	# TrapFiles
	@snmptt_conf_files = $cfg->val('TrapFiles', 'snmptt_conf_files');
	
	$cfg->Delete;
	
	# print "Config file loaded\n";
	
	# 
	# Load config file end
	# 
	##############################################################################
}

sub signal_handler_reload {
	#
	# Daemon reload
	#
	$timetoreload = 1;
}

sub signal_handler_die {
	#
	# Daemon die
	#
	$timetodie = 1;
}

