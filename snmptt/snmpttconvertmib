#!/usr/bin/perl
#
# SNMPTTCONVERTMIB v0.3.1
#
# Copyright 2002 Alex Burger
# alex_b@users.sourceforge.net
#
# 8/14/2002
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
##############################################################################
#
# http://www.sourceforge.net/projects/snmptt
#
###############################################################################
#
# OPTIONS START
#
# Set this to '' to have no default EXEC line added, or modify as needed.
#$defaultexec = '';
$defaultexec = 'qpage -f TRAP notifygroup1';

# Choose what type of quotes (if any) you want around the SUMMARY text pulled from the MIB.
#$defaultexecquote = '';		# no quotes
#$defaultexecquote = "\'";		# single (') quotes
$defaultexecquote = "\"";		# double (") quotes

# Set this to 1 to have the --TYPE string prepended to the --SUMMARY string.
# Set to 0 to disable
$prepend_type = 1;

#
# OPTIONS END
#
#############################################################################
#

$snmpttconvertmib_version = "v0.3.1";

sub showversion
{
  print "\nSNMPTTCONVERTMIB $snmpttconvertmib_version\n";
  print "(c) 2002 Alex Burger\n";
  print "http://snmptt.sourceforge.net\n\n";
}

##############################################################################
# Process command line arguments

$| = 1;

use Getopt::Long;

$DEBUGGING = 0;

$version = 0;
$debug = 0;
$help = 0;
$net_snmp_perl = 0;
$in = '';
$out = '';
$nodes = '';
$no_description = 0;
$no_variables = 0;
$no_format_summary = 0;
$no_format_desc = 0;
$format = 0;
$format_desc = 0;
$no_desc_wildcard = 0;
$no_severity = 0;
$severity = 'Normal';
$exec = '';


GetOptions 	('version' => \$version,
		'debug:i' => \$debug,
		'help' => \$help,
		'in=s' => \$in,
		'out=s' => \$out,
		'net_snmp_perl' => \$net_snmp_perl,
		'nodes=s' => \$nodes,
		'no_description' => \$no_description,
		'no_variables' => \$no_variables,
		'no_format_summary' => \$no_format_summary,
		'no_format_desc' => \$no_format_desc,
		'no_severity' => \$no_severity,
		'severity=s' => \$severity,
		'format=n' => \$format,
		'format_desc=n' => \$format_desc,
		'no_desc_wildcard' => \$no_desc_wildcard,
		'exec=s' => \$exec);

if ($version == 1)
{
  &showversion;
  exit(0);
}

if ($help == 1)
{
  &show_help();
  exit(0);
}

# Replace any spaces with -'s in severity
$severity =~ s/ /-/g;

if ($debug == 1)
{
  $DEBUGGING = 1;
}
if ($debug == 2)
{
  $DEBUGGING = 2;
}

$input = $in;
$output = $out;

if ($exec ne '')
{
  $defaultexec = $exec;
}

#print "nodes: $nodes\n";

if (($input eq "") || ($output eq ""))
{
  print "\nMissing arguments!\n";
  &show_help();
  die;
}

if ($net_snmp_perl == 1)
{
  require SNMP;
  $SNMP::save_descriptions = 1;	# Need them only for looking up variable descriptions. 
                                # Do TRAP definition by hand to be able to pull out 
				# the SUMMARY lines
  &SNMP::initMib();
  
  print "\n\n*****  Using UCD-SNMP / NET-SNMP Perl module *****\n\n";
}
else
{
  print "\n\n*****  Processing MIB file WITHOUT using UCD-SNMP / NET-SNMP Perl module *****\n\n";
  check_snmptranslate_version();
}

print "severity: $severity\n";
print "\nFile to load is:	$input\n";
print "File to APPEND TO:	$output\n";

if ($DEBUGGING >= 1)
{
  print "\nLoading$input\n";
}

unless (open INPUTFILE, "<$input")
{
  die "Cannot open input file: $!";
}

while (<INPUTFILE>)
{
  chomp;				# remove <cr> at end of line
  s/\015//;			# Remove any DOS carriage returns
  push(@mibfile, $_);		# add to each line to @trapconf array
}

if ($DEBUGGING >= 1)
{
  print "Finished loading $input\n\n";
}

$currentline=0;

unless (open OUTPUTFILE, ">>$output")
{
  die "Cannot open output file: $!";
}

print OUTPUTFILE "#\n#\n#\n#\n";
print OUTPUTFILE "MIB: $input converted on " . scalar(localtime) . " using snmpttconvertmib $snmpttconvertmib_version\n";

# Determine name of MIB file
$mib_name = '';
while ($currentline <= $#mibfile)
{
  $line = $mibfile[$currentline];
  if ($line =~ /(.*)DEFINITIONS\s+::=\s+BEGIN/)
  {
    $mib_name = $1;
    $mib_name =~ s/\s+//g;
    print "Name of MIB:            $mib_name\n";
    last;
  }
  $currentline++;
}

if ($mib_name eq '')
{
  print "\n\nAborting!!!\n";
  print "Could not find DEFINITIONS ::= BEGIN statement in MIB file!\n\n";
  exit (1);
}

# Set MIBS environment to only point to the selected MIB.  Speeds things up!
$ENV{'MIBS'} = $mib_name;

$currentline=0;
if ($net_snmp_perl == 0)
{
  # Process the trap files by hand
   
  while ($currentline <= $#mibfile)
  {
    $line = $mibfile[$currentline];

    # TRAP-TYPE (V1) / NOTIFICATION-TYPE (V2)
    #
    # eg: 'mngmtAgentTrap-23003 TRAP-TYPE';
    # eg: 'ciscoSystemClockChanged NOTIFICATION-TYPE';
    if ( $line =~ /(.*)\s+TRAP-TYPE.*/ || $line =~ /(.*)\s+NOTIFICATION-TYPE.*/ )
    {
      if ( $line =~ /(.*)\s+TRAP-TYPE.*/ )
      {
        $trapversion = 'TRAP';
      }
      else
      {
        $trapversion = 'NOTIFICATION';
      }
      
      $enterprisefound = 0;
      
      @variables = ();
      
      # If the TRAP-TYPE / NOTIFICATION-TYPE line starts with white space, it's probably a import line, so ignore
      if ( $line =~ /^\s+TRAP-TYPE.*/ || $line =~ /^\s+NOTIFICATION-TYPE.*/  ||
      $line =~ /^.*,.*NOTIFICATION-TYPE.*/ )
      {
        print "skipping a TRAP-TYPE / NOTIFICATION-TYPE line - probably an import line.\n";
        $currentline++; # Increment to the next line
        $line = $mibfile[$currentline]; # Get next line
        next;
      }
      
      $trapname = $1;
      
      # Remove beginning and trailing white space
      $trapname =~ /\s*([A-Za-z0-9_-]+)\s*/;
      $trapname = $1;
      
      
      print "#\n";
      print "Line: $currentline\n";
      if ($trapversion eq 'TRAP')
      {
        print "TRAP-TYPE: $1\n";		# If trapsummary blank, use trapsummary line for FORMAT and EXEC
      }
      else
      {
        print "NOTIFICATION-TYPE: $1\n";	# If trapsummary blank, use trapsummary line for FORMAT and EXEC
      }
      
      $currentline++; # Increment to the next line
      $line3 = $mibfile[$currentline];
      
      $end_of_definition = 0;
      
      while ( ($currentline <= $#mibfile) && !($line3 =~ /(.*)\s+TRAP-TYPE.*/ )
      && !($line3 =~ /(.*)\s+NOTIFICATION-TYPE.*/) && ($end_of_definition == 0) )
      {
        # Keep going through the file until the next TRAP-TYPE / NOTIFICATION-TYPE or the end of the mib file
        # is reached
        
        # Look for DESCRIPTION and anything after (including newline with /s)
        # and capture that anything in $1
        
        # If line starts with ENTERPRISE, pull it out
        # Only applies to SNMPv1 TRAPs
        # (SNMPv2 NOTIFICATIONS have the enterprise in the ::= line)
	
	$traptype = "";
	$trapsummary = "";
	@description = ();
	$trap_severity = $severity;
	
        if ($line3 =~ /ENTERPRISE\s+(.*)/)
        {
          $enterprise = $1;
          $enterprisefound =1;
        }

        if ($line3 =~ /VARIABLES(.*)/s)
        {
	  # If there is more text after the word VARIABLES, assume it's the start of
	  # the variable list
	  my $templine = "";
	  if ($1 ne "")
          {
            $templine = $templine . $1;
	  }
	  
	  if ($templine =~ /(.*)\}$/)	# Ends with a }, so we're done
	  {
	    # DONE!
	  }
	  else
	  {
	    $currentline++; # Increment to the next line
	    my $line4 = $mibfile[$currentline];
	    my $keepdigging = 1;
	    while ($keepdigging == 1)
	    {
	      if ($line4 =~ /(.*)\}$/)	# Ends with a }, so we're done
	      {
		$templine = $templine . $line4;
		$keepdigging = 0;
	      }
	      else
	      {
                $line4 =~ s/--.*//; # Remove any trailing comments
		$templine = $templine . $line4;
		$currentline++; # Increment to the next line
		$line4 = $mibfile[$currentline];
	      }
	    }
	  }
	  $templine =~ s/\s//g;	# Remove any white space
	  $templine =~ /\{(.*)\}/;
	  @variables = split /\,/, $1;
	  print "Variables: @variables\n";
	}
	
        if ($line3 =~ /DESCRIPTION(.*)/s)
        {
          $temp1 = 0;
         
          # Start of DESCRIPTION
          
          #print "SDESC\n";
          
          # If there is more text after the word DESCRIPTION, assume it's the start of
          # the description.
          if ($1 ne "")
          {
            # Pull out text and remove beginning and trailing white space
            if ($1 =~ /\s*(.*)\s*/)
            {
              # Remove any quotes
              $_ = $1;
              s(\")()g;
              # "
              push (@description, "$_\n");
              
            }
          }
          
          $currentline++; # Increment to the next line
          $line4 = $mibfile[$currentline];
          
          # Assume the rest is the description up until a ::= or end of the file
          while (! ($line4 =~ /::=/))
          {
            # If next line is a --#TYPE, pull out the information and place in $traptype
            if ($line4 =~ /--#TYPE(.*)/)
            {
              
              # Pull out text and remove beginning and trailing white space and quotes
              if ($line4 =~ /\s*--#TYPE\s*(.*)\s*/)
              {
                # Remove any quotes
                $_ = $1;
                s(\")()g;
                # "
                
                #print ("2\n");
                $traptype = $_;
                #print "Type: $traptype \n";
              }
              
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            
            # If next line is a --#SUMMARY, pull out the information and place in $summary
            if ($line4 =~ /--#SUMMARY(.*)/)
            {
              
              # Pull out text and remove beginning and trailing white space and quotes
              if ($line4 =~ /\s*--#SUMMARY\s*(.*)\s*/)
              {
                # Remove any quotes
                $_ = $1;
                s(\")()g;
                # "
                
                #print ("2\n");
                $trapsummary .= $_;
                #print "Summary: $trapsummary \n";
              }
              
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            # If next line is a --#ARGUMENTS, pull out the information and place in $arguments
            if ($line4 =~ /--#ARGUMENTS {(.*)}/)
            {
              @arguments = split /,/, $1;
              
              for($i=0;$i <= $#arguments;$i++)
              {
                #print "argument $i: $arguments[$i]\n";
              }
              
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
	    # If next line is a --#SEVERITY, pull out the information and place in $trap_severity
            if ($line4 =~ /--#SEVERITY(.*)/)
            {
              # Pull out text and remove beginning and trailing white space and quotes
              if ($line4 =~ /\s*--#SEVERITY\s*(.*)\s*/)
              {
                # Remove any quotes
                $_ = $1;
                s(\")()g;
                # "
                
                #print ("2\n");
                if ($no_severity == 0)
		{
		  $trap_severity = $_;
		}
                #print "Severity: $trap_severity \n";
              }
              # Increment to next line and continue with the loop
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            # If next line starts with a --#, ignore it and continue with the loop
            # (we already got the SUMMARY line above)
            if ($line4 =~ /--#/)
            {
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              next;
            }
            
            # If we did not find text after the word DESCRIPTION, then the NEXT
            # line must be the first line of description.
            
            # Remove beginning and trailing white space
            $line4 =~ (/\s*(.*)\s*/);
            if ($1 ne "")
            {
              # Remove any quotes
              $_ = $1;
              s(\")()g;
              # "
              
              push (@description, "$_\n");
              #print "c:$_\n";
            }
            
            $currentline++; # Increment to the next line
            $line4 = $mibfile[$currentline];
          }
          #print "EDESC\n";
          
          if ($line4 =~ /::=/)
          {
            $end_of_definition = 1;		# Move on to the next one
            
            if ($enterprisefound == 0)
            {
              # $line4 should now contain ::= line
              # # Pull out enterprise from { }
              # # Would only apply to SNMPv2 NOTIFICATIONS
              # #print "Line4: $line4\n";
              $line4 =~ /{(.*)\s\d.*/;
              
              #print "\$1=$1\n";
              $enterprisefound =1;
              
              # Remove any spaces
              $_ = $1;
              s( )()g;
              $enterprise = $_;
              print "Enterprise: $enterprise\n";
            }
          }
        }
        $currentline++; # Increment to the next line
        $line3 = $mibfile[$currentline];
      }
      
      # Combine Trap type and summary together to make new summary
      if ($traptype ne "" && $prepend_type == 1)
      {
        $trapsummary = $traptype . ": " . $trapsummary;
      }
      
      if ($mib_name eq '')
      {
	$trap_lookup = $trapname;
      }
      else
      {
	$trap_lookup = "$mib_name\:\:$trapname";
      }
      print "Looking up via snmptranslate: $trap_lookup\n";
      
      if ($snmptranslate_use_On == 1)
      {
        if ($trapversion eq 'TRAP')
        {
          $trapoid = `snmptranslate -IR -Ts -On $trap_lookup`;
        }
        else
        {
          $trapoid = `snmptranslate -On -IR -Ts $trap_lookup`;
        }
      }
      else
      {
        if ($trapversion eq 'TRAP')
        {
          $trapoid = `snmptranslate -IR -Ts $trap_lookup`;
        }
        else
        {
          $trapoid = `snmptranslate -IR -Ts $trap_lookup`;
        }
      }
      
      chomp $trapoid;
      if ($trapoid ne "")
      {
        print OUTPUTFILE "#\n#\n#\n";
        print OUTPUTFILE "EVENT $trapname $trapoid \"Status Events\" $trap_severity\n";
        
        # Loop through trapsummary and replace the %s and %d etc with %1 to %n
        
        $j = $#arguments; # j is last element number
        
        #print "j is $j\n";
        
        # Change the %s or %d etc into $1 etc (starts at $1)
        $_ = $trapsummary;
        for ($j=0; $j<= $#arguments; $j++)
        {
          $variable = ($arguments[$j])+1;
          s(%[a-zA-Z])(\$$variable);
        }
        
        #print "new summary: $_\n";
        
        $trapsummary = $_;
        
        $descriptionline1 = '';
        
        # Build description line for FORMAT / EXEC
        if ($format_desc == 0)		# First line of description
        {
          $descriptionline1 = $description[0];
          chomp ($descriptionline1);
        }
        else				# n sentence(s) of description
        {
          # Build single line copy of description
          my $description_temp;
          foreach my $a (@description)
          {
            my $b = $a;
            chomp($b);
            $description_temp = $description_temp . $b . " ";
          }
          chop $description_temp;
          
          # Split up based on sentences
          my @description_temp2 = split /\./, $description_temp;
          
          # Remove white space around each sentence and add a trailing .
          for (my $i=0 ; $i <= $#description_temp2; $i++)
          {
            $description_temp2[$i] =~ /\s*(.*)\s*/;
            $description_temp2[$i] = $1 . ".";
          }
          
          # Build description line based on the number of sentences requested.
          for (my $i=1 ; $i <= $format_desc; $i++)
          {
            $descriptionline1 = $descriptionline1 . $description_temp2[$i-1] . " " ;
          }
          chop $descriptionline1;	# Remove last space
        }
        
        if ($descriptionline1 ne "")
        {
          if ($descriptionline1 =~ /%[a-zA-Z]/)
          {
            # Sometimes the variables are in the first line of the description
            # Change the %s or %d etc into $1 etc (starts at $1)
            # There is no list of variables, so just put them in order starting at 1 and
            # going up to 20
            $_ = $descriptionline1;
            for ($j=1; $j<= 20; $j++)
            {
              s(%[a-zA-Z])(\$$j);
            }
            $descriptionline1 = $_;
            $descriptionlinehadvariables = 1;
          }
          else
          {
            if ($no_desc_wildcard == 0)
            {
              $descriptionline1 = "$descriptionline1 \$*";
            }
          }
        }
        
        $formatexec = '';
        
        if ($format == 0)	# --#SUMMARY or description
        {
          if ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $trapsummary;
          }
          elsif ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            $formatexec = $descriptionline1;
          }
        }
        elsif ($format == 1)	# description or --#SUMMARY
        {
          if ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            $formatexec = $descriptionline1;
          }
          elsif ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $trapsummary;
          }
        }
        elsif ($format == 2)	# --#SUMMARY and description
        {
          if ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $trapsummary;
          }
          if ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            if ($formatexec =~ /\.$/)	# If it already ends in a .
            {
              $formatexec = $formatexec . " " . $descriptionline1;
            }
            else
            {
              $formatexec = $formatexec . ". " . $descriptionline1;
            }
          }
        }
        elsif ($format == 3)	# description and --#SUMMARY
        {
          if ($descriptionline1 ne '' && $no_format_desc == 0)
          {
            $formatexec = $descriptionline1;
          }
          if ($trapsummary ne '' && $no_format_summary == 0)
          {
            $formatexec = $formatexec . " " . $trapsummary;
          }
        }
        
        if ($formatexec ne '')
        {
          print OUTPUTFILE "FORMAT $formatexec\n";
          if ($defaultexec ne '')
          {
            print OUTPUTFILE "EXEC $defaultexec $defaultexecquote$formatexec$defaultexecquote\n"
          }
        }
        else
        {
          print OUTPUTFILE "FORMAT \$*\n";
          if ($defaultexec ne '')
          {
            print OUTPUTFILE "EXEC $defaultexec $defaultexecquote\$*$defaultexecquote\n"
          }
          #print OUTPUTFILE "EXEC \$*\n";
        }
        
        if ($nodes ne '')
        {
          print OUTPUTFILE "NODES $nodes\n";
        }
        
        if ($no_description == 0)
        {
          print OUTPUTFILE "SDESC\n";
          #print OUTPUTFILE "$descriptionline1\n";
          for ($i=0; $i <= $#description; $i++)
          {
            print OUTPUTFILE "$description[$i]";
          }

	  if (@variables ne "" && $no_variables == 0)
	  {
	    print OUTPUTFILE "Variables:\n";
	    for ($i=0; $i <= $#variables; $i++)
	    {
	      print OUTPUTFILE "  " . ($i+1) . ": " . $variables[$i] . "\n";
	    }
	  }
          print OUTPUTFILE "EDESC\n";
        }
        
        $currentline--;
      }
      
      print "OID: $trapoid\n";
      #print "\@description is ", $#description,"\n";
      #print "going to next trap / notification\n\n";
    }
    
    $currentline++; # Increment to the next line
  }
  
  
  sub check_snmptranslate_version
  {
    $snmptranslate_use_On = 1;
    
    if (open SNMPTRANSLATE, "snmptranslate -V 2>&1|")
    {
      $snmptranslatever = <SNMPTRANSLATE>;
      close SNMPTRANSLATE;
      
      chomp ($snmptranslatever);
      
      print "snmptranslate version: " . $snmptranslatever. "\n";
      
      if ($snmptranslatever =~ /UCD/i || $snmptranslatever =~ /NET-SNMP version: 5.0.1/i)
      {
        $snmptranslate_use_On = 0;
        if ($DEBUGGING >= 1)
        {
          print "snmptranslate is either UCD-SNMP, or NET-SNMP v5.0.1, so do not use the -On switch.  Version found: $snmptranslatever\n";
        }
      }
    }
  }
  
  # End of process the trap files by hand
}
else
{
  #Process the trap files using NET-SNMP Perl
  
  foreach $key (sort keys %SNMP::MIB)
  {
    if (($SNMP::MIB{$key}{type} eq 'TRAP' || $SNMP::MIB{$key}{type} eq 'NOTIF') && $SNMP::MIB{$key}{moduleID} eq $mib_name )
    {
      #print "#\n#\n#\n";
      
      if ($SNMP::MIB{$key}{type} eq 'TRAP')
      {
        print "TRAP-TYPE: $SNMP::MIB{$key}{label}\n";		# If trapsummary blank, use trapsummary line for FORMAT and EXEC
      }
      else
      {
        print "NOTIFICATION-TYPE: $SNMP::MIB{$key}{label}\n";	# If trapsummary blank, use trapsummary line for FORMAT and EXEC
      }
      
      #print "EVENT $SNMP::MIB{$key}{label} $key \"Status Events\" Normal\n";
      
      # Determine FORMAT line
      
      $currentline=0;
      while ($currentline <= $#mibfile)
      {
        $line = $mibfile[$currentline];
        if ( $line =~ /$SNMP::MIB{$key}{label}\s+TRAP-TYPE.*/  || $line =~ /$SNMP::MIB{$key}{label}\s+NOTIFICATION-TYPE.*/)
        {
          $currentline++; # Increment to the next line
          $line3 = $mibfile[$currentline];
          
          $end_of_definition = 0;
	  @variables = ();
          
          while ( ($currentline <= $#mibfile) && !($line3 =~ /(.*)\s+TRAP-TYPE.*/ )
          && !($line3 =~ /(.*)\s+NOTIFICATION-TYPE.*/) && ($end_of_definition == 0) )
          {
            # Keep going through the file until the next TRAP-TYPE or the end of the mib file
            # is reached
            
            # Look for DESCRIPTION and anything after (including newline with /s)
            # and capture that anything in $1
            
            $traptype = "";
	    $trapsummary = "";
	    @description = ();
	    $trap_severity = $severity;

            if ($line3 =~ /VARIABLES(.*)/s)
            {
	      # If there is more text after the word VARIABLES, assume it's the start of
	      # the variable list
	      my $templine = "";
	      if ($1 ne "")
	      {
		$templine = $templine . $1;
	      }
	      
	      if ($templine =~ /(.*)\}$/)	# Ends with a }, so we're done
	      {
		# DONE!
	      }
	      else
	      {
		$currentline++; # Increment to the next line
		my $line4 = $mibfile[$currentline];
		my $keepdigging = 1;
		while ($keepdigging == 1)
		{
		  if ($line4 =~ /(.*)\}$/)	# Ends with a }, so we're done
		  {
		    $templine = $templine . $line4;
		    $keepdigging = 0;
		  }
		  else
		  {
		    $templine = $templine . $line4;
		    $currentline++; # Increment to the next line
		    $line4 = $mibfile[$currentline];
		  }
		}
	      }
	      $templine =~ s/\s//g;	# Remove any white space
	      $templine =~ /\{(.*)\}/;
	      @variables = split /\,/, $1;
	      print "Variables: @variables\n";
	    }
	    
            if ($line3 =~ /DESCRIPTION(.*)/s)
            {
              $temp1 = 0;
              
              # Start of DESCRIPTION
              
              #print "SDESC\n";
              
              # If there is more text after the word DESCRIPTION, assume it's the start of
              # the description.  If it is, pull it out and place in $descriptionline1.
              if ($1 ne "")
              {
                # Pull out text and remove beginning and trailing white space
                if ($1 =~ /\s*(.*)\s*/)
                {
                  #print ("2\n");
                  # Remove any quotes
                  $_ = $1;
                  s(\")()g;
                  # "
                  $descriptionline1 = $_;
                  $temp1 = 1;
                  
                  push (@description, "$_\n");
                  #print "Line 1a: $_ \n";
                }
              }
              
              $currentline++; # Increment to the next line
              $line4 = $mibfile[$currentline];
              
              # Assume the rest is the description up until a ::= or end of the file
              while (! ($line4 =~ /::=/))
              {
                # If next line is a --#TYPE, pull out the information and place in $traptype
                if ($line4 =~ /--#TYPE(.*)/)
                {
                  
                  # Pull out text and remove beginning and trailing white space and quotes
                  if ($line4 =~ /\s*--#TYPE\s*(.*)\s*/)
                  {
                    # Remove any quotes
                    $_ = $1;
                    s(\")()g;
                    # "
                    
                    #print ("2\n");
                    $traptype = $_;
                    #print "Type: $traptype \n";
                  }
                  
                  # Increment to next line and continue with the loop
                  $currentline++; # Increment to the next line
                  $line4 = $mibfile[$currentline];
                  next;
                }
                
                # If next line is a --#SUMMARY, pull out the information and place in $summary
                if ($line4 =~ /--#SUMMARY(.*)/)
                {
                  
                  # Pull out text and remove beginning and trailing white space and quotes
                  if ($line4 =~ /\s*--#SUMMARY\s*(.*)\s*/)
                  {
                    # Remove any quotes
                    $_ = $1;
                    s(\")()g;
                    # "
                    
                    #print ("2\n");
                    $trapsummary .= $_;
                    #print "Summary: $trapsummary \n";
                  }
                  
                  # Increment to next line and continue with the loop
                  $currentline++; # Increment to the next line
                  $line4 = $mibfile[$currentline];
                  next;
                }
                # If next line is a --#ARGUMENTS, pull out the information and place in $arguments
                if ($line4 =~ /--#ARGUMENTS {(.*)}/)
                {
                  @arguments = split /,/, $1;
                  
                  for($i=0;$i <= $#arguments;$i++)
                  {
                    #print "argument $i: $arguments[$i]\n";
                  }
                  
                  # Increment to next line and continue with the loop
                  $currentline++; # Increment to the next line
                  $line4 = $mibfile[$currentline];
                  next;
                }
		# If next line is a --#SEVERITY, pull out the information and place in $trap_severity
                if ($line4 =~ /--#SEVERITY(.*)/)
                {
                  # Pull out text and remove beginning and trailing white space and quotes
                  if ($line4 =~ /\s*--#SEVERITY\s*(.*)\s*/)
                  {
                    # Remove any quotes
                    $_ = $1;
                    s(\")()g;
                    # "
                    
                    #print ("2\n");
                    if ($no_severity == 0)
		    {
		      $trap_severity = $_;
		    }
		    #print "Severity: $trap_severity \n";
		  }
                  # Increment to next line and continue with the loop
                  $currentline++; # Increment to the next line
                  $line4 = $mibfile[$currentline];
                  next;
                }
                # If next line starts with a --#, ignore it and continue with the loop
                # (we already got the SUMMARY line above)
                if ($line4 =~ /--#/)
                {
                  $currentline++; # Increment to the next line
                  $line4 = $mibfile[$currentline];
                  next;
                }
                # If we did not find text after the word DESCRIPTION, then the NEXT
                # line must be the first line of description.  Pull that out and place
                # in $descriptionline1.
                if ($temp1 == 0)
                {
                  # Remove beginning and trailing white space
                  $line4 =~ (/\s*(.*)\s*/);
                  # Remove any quotes
                  $_ = $1;
                  s(\")()g;
                  # "
                  $descriptionline1 = $_;
                  
                  push (@description, "$_\n");
                  #print "Line 1b: $_ \n";
                  $temp1 = 1;
                }
                else
                {
                  # Remove beginning and trailing white space
                  $line4 =~ (/\s*(.*)\s*/);
                  if ($1 ne "")
                  {
                    # Remove any quotes
                    $_ = $1;
                    s(\")()g;
                    # "
                    
                    push (@description, "$_\n");
                    #print "c:$_\n";
                  }
                }
                
                $currentline++; # Increment to the next line
                $line4 = $mibfile[$currentline];
              }
              #print "EDESC\n";
              
              if ($line4 =~ /::=/)
              {
                $end_of_definition = 1;		# Move on to the next one
              }
            }
            $currentline++; # Increment to the next line
            $line3 = $mibfile[$currentline];
          }
          
          # Combine Trap type and summary together to make new summary
          if ($traptype ne "" && $prepend_type == 1)
          {
            $trapsummary = $traptype . ": " . $trapsummary;
          }
          
          $trapoid = $key;
          $trapname = $SNMP::MIB{$key}{label};
          chomp $trapoid;
          if ($trapoid ne "")
          {
            print OUTPUTFILE "#\n#\n#\n";
            print OUTPUTFILE "EVENT $trapname $trapoid \"Status Events\" $trap_severity\n";
            
            # Loop through trapsummary and replace the %s and %d etc with %1 to %n
            
            $j = $#arguments; # j is last element number
            
            #print "j is $j\n";
            
            # Change the %s or %d etc into $1 etc (starts at $1)
            $_ = $trapsummary;
            for ($j=0; $j<= $#arguments; $j++)
            {
              $variable = ($arguments[$j])+1;
              s(%[a-zA-Z])(\$$variable);
            }
            
            #print "new summary: $_\n";
            
            $trapsummary = $_;
            
            $descriptionline1 = '';
            
            # Build description line for FORMAT / EXEC
            if ($format_desc == 0)		# First line of description
            {
              $descriptionline1 = $description[0];
              chomp ($descriptionline1);
            }
            else				# n sentence(s) of description
            {
              # Build single line copy of description
              my $description_temp;
              foreach my $a (@description)
              {
                my $b = $a;
                chomp($b);
                $description_temp = $description_temp . $b . " ";
              }
              chop $description_temp;
              
              # Split up based on sentences
              my @description_temp2 = split /\./, $description_temp;
              
              # Remove white space around each sentence and add a trailing .
              for (my $i=0 ; $i <= $#description_temp2; $i++)
              {
                $description_temp2[$i] =~ /\s*(.*)\s*/;
                $description_temp2[$i] = $1 . ".";
              }
              
              # Build description line based on the number of sentences requested.
              for (my $i=1 ; $i <= $format_desc; $i++)
              {
                $descriptionline1 = $descriptionline1 . $description_temp2[$i-1] . " " ;
              }
              chop $descriptionline1;	# Remove last space
            }
            
            if ($descriptionline1 ne "")
            {
              if ($descriptionline1 =~ /%[a-zA-Z]/)
              {
                # Sometimes the variables are in the first line of the description
                # Change the %s or %d etc into $1 etc (starts at $1)
                # There is no list of variables, so just put them in order starting at 1 and
                # going up to 20
                $_ = $descriptionline1;
                for ($j=1; $j<= 20; $j++)
                {
                  s(%[a-zA-Z])(\$$j);
                }
                $descriptionline1 = $_;
                $descriptionlinehadvariables = 1;
              }
              else
              {
                if ($no_desc_wildcard == 0)
                {
                  $descriptionline1 = "$descriptionline1 \$*";
                }
              }
            }
            
            $formatexec = '';
            
            if ($format == 0)	# --#SUMMARY or description
            {
              if ($trapsummary ne '' && $no_format_summary == 0)
              {
                $formatexec = $trapsummary;
              }
              elsif ($descriptionline1 ne '' && $no_format_desc == 0)
              {
                $formatexec = $descriptionline1;
              }
            }
            elsif ($format == 1)	# description or --#SUMMARY
            {
              if ($descriptionline1 ne '' && $no_format_desc == 0)
              {
                $formatexec = $descriptionline1;
              }
              elsif ($trapsummary ne '' && $no_format_summary == 0)
              {
                $formatexec = $trapsummary;
              }
            }
            elsif ($format == 2)	# --#SUMMARY and description
            {
              if ($trapsummary ne '' && $no_format_summary == 0)
              {
                $formatexec = $trapsummary;
              }
              if ($descriptionline1 ne '' && $no_format_desc == 0)
              {
                if ($formatexec =~ /\.$/)	# If it already ends in a .
                {
                  $formatexec = $formatexec . " " . $descriptionline1;
                }
                else
                {
                  $formatexec = $formatexec . ". " . $descriptionline1;
                }
              }
            }
            elsif ($format == 3)	# description and --#SUMMARY
            {
              if ($descriptionline1 ne '' && $no_format_desc == 0)
              {
                $formatexec = $descriptionline1;
              }
              if ($trapsummary ne '' && $no_format_summary == 0)
              {
                $formatexec = $formatexec . " " . $trapsummary;
              }
            }
            
            if ($formatexec ne '')
            {
              print OUTPUTFILE "FORMAT $formatexec\n";
              if ($defaultexec ne '')
              {
                print OUTPUTFILE "EXEC $defaultexec $defaultexecquote$formatexec$defaultexecquote\n"
              }
            }
            else
            {
              print OUTPUTFILE "FORMAT \$*\n";
              if ($defaultexec ne '')
              {
                print OUTPUTFILE "EXEC $defaultexec $defaultexecquote\$*$defaultexecquote\n"
              }
              #print OUTPUTFILE "EXEC \$*\n";
            }
            
            if ($nodes ne '')
            {
              print OUTPUTFILE "NODES $nodes\n";
            }
            
            if ($no_description == 0)
            {
              print OUTPUTFILE "SDESC\n";
              #print OUTPUTFILE "$descriptionline1\n";
              for ($i=0; $i <= $#description; $i++)
              {
                print OUTPUTFILE "$description[$i]";
              }
	      if (@variables ne "" && $no_variables == 0)
	      {
		print OUTPUTFILE "Variables:\n";
		for ($i=0; $i <= $#variables; $i++)
		{
		  print OUTPUTFILE "  " . ($i+1) . ": " . $variables[$i] . "\n";
		  print OUTPUTFILE "     Syntax=\"" . $SNMP::MIB{$variables[$i]}{type} . "\"\n";
		  if (uc $SNMP::MIB{$variables[$i]}{type} =~ /INTEGER/)
		  {
		    my $b = $SNMP::MIB{$variables[$i]}{enums};
		    my %hash = %$b;
		    my $i = 1;
		    
		    # Create a new copy of the hash swapping the key and the value
		    my %temphash = ();
		    while ((my $key, my $value) = each %hash)
		    {
		      $temphash{$value} = $key;
		    }
		    # Print out the entries in the hash
		    foreach $c (sort keys %temphash)
		    {
		      print OUTPUTFILE "       " . $c . ": $temphash{$c}\n";
		    }
		  }

		  print OUTPUTFILE "     Descr=\"" . $SNMP::MIB{$variables[$i]}{description} . "\"\n";
		}
	      }
              print OUTPUTFILE "EDESC\n";
            }
            
            $currentline--;
          }
          
          print "OID: $trapoid\n\n";
          #print "\@description is ", $#description,"\n";
          #print "going to next trap\n\n";
        }
        $currentline++;
      } #end of while
    }
  }
  #End of process the trap files using NET-SNMP Perl
}

sub show_help
{
  $USAGE = qq/Usage:
  snmpttconvertmib [<options>]
Options:
  --debug=n              Set debug level (1 or 2)
  --help                 Display this message
  --version              Display author and version information
  --net_snmp_perl        Use NET-SNMP Perl integration instead of
			 NET-SNMP snmptranslate utility
  --in=filename          Input file
  --out=filename         Output file
  --nodes=name or file   If specified, will insert a NODES line after FORMAT or 
  			 EXEC.  The host name(s) separated by spaces, or the 
			 name of the nodes file.  Use quotes for multiple
			 entries.  See NODES section in readme.html for examples
  --no_description	 Do not save the description
  --no_variables	 Do not save the variable list in the description
  --no_format_summary	 Do not use the --#SUMMARY lines for FORMAT \/ EXEC
  --no_format_desc	 Do not use the description line for FORMAT \/ EXEC
  --no_severity 	 Do not use the --#SEVERITY line for EVENT line.  Default
                         severity of "Normal" will be used, unless --severity= is 
			 set
  --severity=s  	 Severity level for EVENT line.  Only used if there is no
                         --#SEVERITY line, or --no_severity is set.  Must NOT 
			 contain any spaces.
			 Example: 
			   Critical
  --format=n		 FORMAT \/ EXEC order preference
			   0 = --#SUMMARY or description
			   1 = description or --#SUMMARY
			   2 = --#SUMMARY and description
			   3 = description and --#SUMMARY
  --format_desc=n	 How to convert the description line for FORMAT \/ EXEC
			   0 = First line of description
			   n = n sentence(s) of description
  --no_desc_wildcard	 To prevent \$* from being appended to the end of 
  			 description text when used on the FORMAT \/ EXEC 
			 lines.  A wildcard is only used if the description 
			 line contained no variable definitions (\%n).
  --exec=command         Command line to use for EXEC line.  Use SINGLE quotes
                         with Unix.  Example:
    			   'qpage -f TRAP notifygroup1'

  Note:  The only benefit in using the --net_snmp_perl switch (which requires the
         Net-SNMP Perl module to be installed) is that the Variables: description section 
         will include:
           -variable syntax
           -variable description
           -variable enums

	   For example:
           2: globalStatus
              Syntax="INTEGER"
                2: ok
                4: failure
              Descr="Current status of the entire library system"
/;
  
  &showversion;
  print $USAGE . "\n";
}
